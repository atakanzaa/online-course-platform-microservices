# GitLab CI/CD Pipeline for Online Course Platform Microservices
# This pipeline handles build, test, security scanning, and deployment for all services

stages:
  - validate
  - build
  - test
  - security
  - package
  - deploy-staging
  - integration-test
  - deploy-production
  - monitoring

variables:
  # Docker Registry Configuration
  DOCKER_REGISTRY: "registry.gitlab.com"
  DOCKER_NAMESPACE: "${CI_PROJECT_NAMESPACE}/${CI_PROJECT_NAME}"
  
  # Application Configuration
  APP_VERSION: "${CI_COMMIT_SHORT_SHA}"
  STAGING_NAMESPACE: "course-platform-staging"
  PRODUCTION_NAMESPACE: "course-platform-production"
  
  # Security and Quality
  SAST_EXCLUDED_ANALYZERS: "eslint, semgrep"
  CODE_QUALITY_DISABLED: "false"
  
  # Services Configuration
  SERVICES: "user-service,course-service,payment-service,notification-service,media-service,analytics-service,api-gateway"

# Global configurations
default:
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    - docker info
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY

# Include additional pipeline templates
include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Container-Scanning.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Code-Quality.gitlab-ci.yml

# ==================== VALIDATE STAGE ====================

validate:dockerfile:
  stage: validate
  image: hadolint/hadolint:latest-debian
  script:
    - find . -name "Dockerfile*" -exec hadolint {} +
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

validate:docker-compose:
  stage: validate
  image: docker/compose:alpine-1.29.2
  script:
    - docker-compose -f docker-compose.staging.yml config
    - docker-compose -f docker-compose.production.yml config
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

validate:environment:
  stage: validate
  image: alpine:latest
  script:
    - apk add --no-cache bash
    - ./scripts/validate-environment.sh
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ==================== BUILD STAGE ====================

.build_template: &build_template
  stage: build
  script:
    - |
      if [ -f "services/${SERVICE_NAME}/Dockerfile" ]; then
        echo "Building ${SERVICE_NAME}..."
        docker build \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          --build-arg VCS_REF=${CI_COMMIT_SHA} \
          --build-arg VERSION=${APP_VERSION} \
          -t ${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${SERVICE_NAME}:${APP_VERSION} \
          -t ${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${SERVICE_NAME}:latest \
          services/${SERVICE_NAME}/
        
        docker push ${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${SERVICE_NAME}:${APP_VERSION}
        docker push ${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${SERVICE_NAME}:latest
        
        echo "IMAGE_${SERVICE_NAME^^}=${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${SERVICE_NAME}:${APP_VERSION}" >> build.env
      else
        echo "Dockerfile not found for ${SERVICE_NAME}, skipping..."
      fi
  artifacts:
    reports:
      dotenv: build.env
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

build:user-service:
  <<: *build_template
  variables:
    SERVICE_NAME: "user-service"

build:course-service:
  <<: *build_template
  variables:
    SERVICE_NAME: "course-service"

build:payment-service:
  <<: *build_template
  variables:
    SERVICE_NAME: "payment-service"

build:notification-service:
  <<: *build_template
  variables:
    SERVICE_NAME: "notification-service"

build:media-service:
  <<: *build_template
  variables:
    SERVICE_NAME: "media-service"

build:analytics-service:
  <<: *build_template
  variables:
    SERVICE_NAME: "analytics-service"

build:api-gateway:
  <<: *build_template
  variables:
    SERVICE_NAME: "api-gateway"

# ==================== TEST STAGE ====================

test:unit:
  stage: test
  image: node:18-alpine
  script:
    - npm install
    - npm run test:unit
  coverage: '/Statements.*?(\d+(?:\.\d+)?)%/'
  artifacts:
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:integration:
  stage: test
  services:
    - name: postgres:15-alpine
      alias: postgres
    - name: redis:7-alpine
      alias: redis
    - name: rabbitmq:3-management-alpine
      alias: rabbitmq
  variables:
    POSTGRES_DB: "test_db"
    POSTGRES_USER: "test_user"
    POSTGRES_PASSWORD: "test_password"
    DATABASE_URL: "postgresql://test_user:test_password@postgres:5432/test_db"
    REDIS_URL: "redis://redis:6379"
    RABBITMQ_URL: "amqp://guest:guest@rabbitmq:5672/"
  script:
    - chmod +x scripts/integration-tests.sh
    - ./scripts/integration-tests.sh
  artifacts:
    reports:
      junit: integration-test-results.xml
    when: always
    expire_in: 1 week
  rules:test:performance:
  stage: test
  image: loadimpact/k6:latest
  script:
    - k6 run --summary-trend-stats="avg,min,med,max,p(95),p(99),count" tests/performance/load-test.js
  artifacts:
    reports:
      performance: k6-results.json
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: true

# ==================== SECURITY STAGE ====================

security:trivy:
  stage: security
  image: aquasec/trivy:latest
  script:
    - |
      for service in $(echo $SERVICES | tr ',' ' '); do
        trivy image --format json --output ${service}-security-report.json \
          ${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${service}:${APP_VERSION} || true
      done
  artifacts:
    reports:
      container_scanning: "*-security-report.json"
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

security:secrets:
  stage: security
  image: trufflesecurity/trufflehog:latest
  script:
    - trufflehog filesystem . --json > secrets-report.json
  artifacts:
    reports:
      secret_detection: secrets-report.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: true

# ==================== PACKAGE STAGE ====================

package:helm:
  stage: package
  image: alpine/helm:latest
  script:
    - |
      helm package deployment/helm/course-platform \
        --version ${APP_VERSION} \
        --app-version ${APP_VERSION}
      
      helm repo add --username ${CI_REGISTRY_USER} \
        --password ${CI_REGISTRY_PASSWORD} \
        course-platform ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/helm/stable
      
      helm cm-push course-platform-${APP_VERSION}.tgz course-platform
  artifacts:
    paths:
      - "*.tgz"
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ==================== STAGING DEPLOYMENT ====================

deploy:staging:
  stage: deploy-staging
  image: bitnami/kubectl:latest
  environment:
    name: staging
    url: https://staging.courseplatform.com
    action: start
  script:
    - |
      # Create namespace if it doesn't exist
      kubectl create namespace ${STAGING_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
      
      # Apply secrets and configmaps
      kubectl apply -f deployment/k8s/staging/secrets/ -n ${STAGING_NAMESPACE}
      kubectl apply -f deployment/k8s/staging/configmaps/ -n ${STAGING_NAMESPACE}
      
      # Deploy services using Helm
      helm upgrade --install course-platform-staging \
        deployment/helm/course-platform \
        --namespace ${STAGING_NAMESPACE} \
        --set image.tag=${APP_VERSION} \
        --set environment=staging \
        --set ingress.hosts[0].host=staging.courseplatform.com \
        --values deployment/helm/course-platform/values-staging.yaml \
        --wait --timeout=10m
      
      # Wait for rollout
      kubectl rollout status deployment/api-gateway -n ${STAGING_NAMESPACE} --timeout=600s
      
      # Run health checks
      chmod +x scripts/health-check.sh
      ./scripts/health-check.sh staging
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: manual
      allow_failure: false

# ==================== INTEGRATION TESTING ====================

integration-test:staging:
  stage: integration-test
  image: alpine:latest
  environment:
    name: staging
    action: access
  script:
    - apk add --no-cache curl jq bash
    - chmod +x scripts/integration-tests.sh
    - ENVIRONMENT=staging ./scripts/integration-tests.sh
  artifacts:
    reports:
      junit: staging-integration-results.xml
    when: always
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

smoke-test:staging:
  stage: integration-test
  image: alpine:latest
  script:
    - |
      apk add --no-cache curl
      # Test API Gateway health
      curl -f https://staging.courseplatform.com/health || exit 1
      
      # Test main endpoints
      curl -f https://staging.courseplatform.com/api/v1/users/health || exit 1
      curl -f https://staging.courseplatform.com/api/v1/courses/health || exit 1
      curl -f https://staging.courseplatform.com/api/v1/payments/health || exit 1
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ==================== PRODUCTION DEPLOYMENT ====================

deploy:production:
  stage: deploy-production
  image: bitnami/kubectl:latest
  environment:
    name: production
    url: https://courseplatform.com
    action: start
  script:
    - |
      # Backup current deployment
      kubectl get all -n ${PRODUCTION_NAMESPACE} -o yaml > backup-$(date +%Y%m%d-%H%M%S).yaml
      
      # Create namespace if it doesn't exist
      kubectl create namespace ${PRODUCTION_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
      
      # Apply secrets and configmaps
      kubectl apply -f deployment/k8s/production/secrets/ -n ${PRODUCTION_NAMESPACE}
      kubectl apply -f deployment/k8s/production/configmaps/ -n ${PRODUCTION_NAMESPACE}
      
      # Deploy services using Helm with blue-green strategy
      helm upgrade --install course-platform-production \
        deployment/helm/course-platform \
        --namespace ${PRODUCTION_NAMESPACE} \
        --set image.tag=${APP_VERSION} \
        --set environment=production \
        --set ingress.hosts[0].host=courseplatform.com \
        --set strategy.type=RollingUpdate \
        --set strategy.rollingUpdate.maxSurge=1 \
        --set strategy.rollingUpdate.maxUnavailable=0 \
        --values deployment/helm/course-platform/values-production.yaml \
        --wait --timeout=15m
      
      # Wait for rollout completion
      for service in $(echo $SERVICES | tr ',' ' '); do
        kubectl rollout status deployment/${service} -n ${PRODUCTION_NAMESPACE} --timeout=900s
      done
      
      # Run health checks
      chmod +x scripts/health-check.sh
      ./scripts/health-check.sh production
  artifacts:
    paths:
      - backup-*.yaml
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: false

# ==================== MONITORING STAGE ====================

deploy:monitoring:
  stage: monitoring
  image: bitnami/kubectl:latest
  script:
    - |
      # Deploy Prometheus
      kubectl apply -f monitoring/prometheus.yml -n ${PRODUCTION_NAMESPACE}
      kubectl apply -f monitoring/alert_rules.yml -n ${PRODUCTION_NAMESPACE}
      
      # Deploy Grafana dashboards
      kubectl create configmap grafana-dashboard-microservices \
        --from-file=monitoring/grafana-dashboard-microservices.json \
        -n ${PRODUCTION_NAMESPACE} \
        --dry-run=client -o yaml | kubectl apply -f -
      
      kubectl create configmap grafana-dashboard-business \
        --from-file=monitoring/grafana-dashboard-business.json \
        -n ${PRODUCTION_NAMESPACE} \
        --dry-run=client -o yaml | kubectl apply -f -
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual

performance-test:production:
  stage: monitoring
  image: loadimpact/k6:latest
  script:
    - k6 run --vus 10 --duration 5m tests/performance/production-load-test.js
  artifacts:
    reports:
      performance: production-k6-results.json
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  allow_failure: true

# ==================== CLEANUP AND NOTIFICATION ====================

cleanup:old-images:
  stage: monitoring
  image: alpine:latest
  script:
    - |
      apk add --no-cache curl jq
      
      # Keep only last 10 images per service
      for service in $(echo $SERVICES | tr ',' ' '); do
        echo "Cleaning up old images for ${service}..."
        # This would use GitLab Container Registry API to cleanup old images
        # Implementation depends on your registry cleanup policies
      done
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual

notify:deployment:
  stage: monitoring
  image: alpine:latest
  script:
    - |
      apk add --no-cache curl
      
      # Send deployment notification to Slack/Teams/Discord
      curl -X POST "${SLACK_WEBHOOK_URL}" \
        -H 'Content-type: application/json' \
        --data '{
          "text": "ðŸš€ Course Platform deployed to production",
          "attachments": [{
            "color": "good",
            "fields": [{
              "title": "Version",
              "value": "'${APP_VERSION}'",
              "short": true
            }, {
              "title": "Pipeline",
              "value": "'${CI_PIPELINE_URL}'",
              "short": true
            }]
          }]
        }'
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  when: on_success
  allow_failure: true

# ==================== ROLLBACK CAPABILITY ====================

rollback:production:
  stage: deploy-production
  image: bitnami/kubectl:latest
  script:
    - |
      echo "Rolling back to previous version..."
      helm rollback course-platform-production -n ${PRODUCTION_NAMESPACE}
      
      # Wait for rollback completion
      for service in $(echo $SERVICES | tr ',' ' '); do
        kubectl rollout status deployment/${service} -n ${PRODUCTION_NAMESPACE} --timeout=600s
      done
      
      # Verify health after rollback
      chmod +x scripts/health-check.sh
      ./scripts/health-check.sh production
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  environment:
    name: production
    action: rollback
  services:
    - docker:20.10.16-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - cd $SERVICE_NAME
    - docker build -t $CI_REGISTRY_IMAGE/$SERVICE_NAME:$IMAGE_TAG .
    - docker build -t $CI_REGISTRY_IMAGE/$SERVICE_NAME:latest .
    - docker push $CI_REGISTRY_IMAGE/$SERVICE_NAME:$IMAGE_TAG
    - docker push $CI_REGISTRY_IMAGE/$SERVICE_NAME:latest
  only:
    - main
    - develop

package-config-server:
  <<: *docker_build_template
  variables:
    SERVICE_NAME: config-server

package-discovery-server:
  <<: *docker_build_template
  variables:
    SERVICE_NAME: discovery-server

package-api-gateway:
  <<: *docker_build_template
  variables:
    SERVICE_NAME: api-gateway

package-user-service:
  <<: *docker_build_template
  variables:
    SERVICE_NAME: user-service

package-course-service:
  <<: *docker_build_template
  variables:
    SERVICE_NAME: course-service

package-payment-service:
  <<: *docker_build_template
  variables:
    SERVICE_NAME: payment-service

package-notification-service:
  <<: *docker_build_template
  variables:
    SERVICE_NAME: notification-service

package-media-service:
  <<: *docker_build_template
  variables:
    SERVICE_NAME: media-service

package-analytics-service:
  <<: *docker_build_template
  variables:
    SERVICE_NAME: analytics-service

# Deploy to Staging
deploy-staging:
  stage: deploy-staging
  image: docker/compose:1.29.2
  services:
    - docker:20.10.16-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    COMPOSE_PROJECT_NAME: online-course-platform-staging
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - apk add --no-cache curl
  script:
    - echo "Deploying to staging environment..."
    - export IMAGE_TAG=$CI_COMMIT_SHA
    - docker-compose -f docker-compose.staging.yml down --remove-orphans
    - docker-compose -f docker-compose.staging.yml pull
    - docker-compose -f docker-compose.staging.yml up -d
    - echo "Waiting for services to be healthy..."
    - sleep 60
    - ./scripts/health-check.sh staging
  environment:
    name: staging
    url: http://staging.online-course-platform.com
  only:
    - develop
  when: manual

# Deploy to Production
deploy-production:
  stage: deploy-production
  image: docker/compose:1.29.2
  services:
    - docker:20.10.16-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    COMPOSE_PROJECT_NAME: online-course-platform-production
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - apk add --no-cache curl
  script:
    - echo "Deploying to production environment..."
    - export IMAGE_TAG=$CI_COMMIT_SHA
    - docker-compose -f docker-compose.prod.yml down --remove-orphans || true
    - docker-compose -f docker-compose.prod.yml pull
    - docker-compose -f docker-compose.prod.yml up -d
    - echo "Waiting for services to be healthy..."
    - sleep 90
    - ./scripts/health-check.sh production
  environment:
    name: production
    url: https://online-course-platform.com
  only:
    - main
  when: manual

# Rollback Production
rollback-production:
  stage: deploy-production
  image: docker/compose:1.29.2
  services:
    - docker:20.10.16-dind
  variables:
    COMPOSE_PROJECT_NAME: online-course-platform-production
  script:
    - echo "Rolling back to previous version..."
    - docker-compose -f docker-compose.prod.yml down
    - export IMAGE_TAG=$ROLLBACK_TAG
    - docker-compose -f docker-compose.prod.yml up -d
  environment:
    name: production
    url: https://online-course-platform.com
  when: manual
  only:
    - main
